let rec hanoi (src, tmp, dst) n =
  if n <= 0 then []
  else
    let before = hanoi (src, dst, tmp) (n - 1) in
    let move   = [(src, dst)] in
    let after  = hanoi (tmp, src, dst) (n - 1) in

    (* Construcción manual sin usar @ *)
    let rec concat l1 l2 =
      match l1 with
      | [] -> l2
      | x :: xs -> x :: concat xs l2
    in

    concat before (concat move after)
;;


List.length (hanoi (1,2,3) 3);;


let rec somme l =
  match l with
  | [] -> 0
  | x :: xs -> x + somme xs
;;

let rec dernier l =
  match l with
  | [] -> failwith "Lista vacía"
  | [x] -> x
  | _ :: xs -> dernier xs
;;

let rec map f l =
  match l with
  | [] -> []
  | x :: xs -> (f x) :: map f xs
;;


let rec inserer x l =
  match l with
  | [] -> [x]
  | y :: ys -> if x <= y then x :: l else y :: inserer x ys
;;

let rec triInsertion l =
  match l with
  | [] -> []
  | x :: xs -> inserer x (triInsertion xs)
;;


let rec partage l =
  match l with
  | [] -> ([], [])
  | [x] -> ([x], [])
  | x :: y :: xs ->
      let (l1, l2) = partage xs in
      (x :: l1, y :: l2)
;;

let rec merge l1 l2 =
  match l1, l2 with
  | [], l | l, [] -> l
  | x :: xs, y :: ys ->
      if x <= y
      then x :: merge xs l2
      else y :: merge l1 ys
;;

let rec triFusion l =
  match l with
  | [] | [_] -> l
  | _ ->
      let (l1, l2) = partage l in
      merge (triFusion l1) (triFusion l2)
;;


let fst (a, _) = a;;
let snd (_, b) = b;;


let estFonction l =
  let rec aux vues = function
    | [] -> true
    | (x, _) :: xs ->
        if List.mem x vues then false
        else aux (x :: vues) xs
  in aux [] l
;;

let rec image x l =
  match l with
  | [] -> failwith "No tiene imagen"
  | (a, b) :: xs -> if a = x then b else image x xs
;;

let estInjective f =
  let rec aux imgs = function
    | [] -> true
    | (_, y) :: xs ->
        if List.mem y imgs then false
        else aux (y :: imgs) xs
  in aux [] f
;;


let surcharge f1 f2 =
  let rec aux = function
    | [] -> f1
    | (x, y) :: xs ->
        let f1' = List.filter (fun (a, _) -> a <> x) f1 in
        (x, y) :: aux xs
  in aux f2
;;


let composition f1 f2 =
  let rec aux = function
    | [] -> []
    | (x, y) :: xs ->
        if List.exists (fun (a, _) -> a = y) f1
        then (x, image y f1) :: aux xs
        else aux xs
  in aux f2
;;


let produit f1 f2 =
  List.map (fun (x, y) -> (x, image x f1, image y f2)) []
;;
