
let rec hanoi (src,tmp,dst) n =
  if n <= 0 then []
  else
    let m1 = hanoi (src,dst,tmp) (n-1) in
    let m2 = [(src,dst)] in
    let m3 = hanoi (tmp,src,dst) (n-1) in
    let rec concat a b =
      match a with
      | [] -> b
      | x::xs -> x :: concat xs b
    in
    concat m1 (concat m2 m3)

(* B. LISTES *)
let rec somme l =
  match l with
  | [] -> 0
  | x::xs -> x + somme xs

let rec dernier l =
  match l with
  | [] -> failwith "liste vide"
  | [x] -> x
  | _::xs -> dernier xs

let rec map f l =
  match l with
  | [] -> []
  | x::xs -> f x :: map f xs

(* C. TRI *)
let rec inserer x l =
  match l with
  | [] -> [x]
  | y::ys -> if x <= y then x::l else y::inserer x ys

let rec triInsertion l =
  match l with
  | [] -> []
  | x::xs -> inserer x (triInsertion xs)

let rec partage l =
  match l with
  | [] -> ([],[])
  | [x] -> ([x],[])
  | x::y::xs ->
    let (l1,l2) = partage xs in
    (x::l1,y::l2)

let rec merge l1 l2 =
  match l1,l2 with
  | [],l | l,[] -> l
  | x::xs,y::ys ->
    if x <= y then x :: merge xs l2 else y :: merge l1 ys

let rec triFusion l =
  match l with
  | [] | [_] -> l
  | _ ->
    let (l1,l2) = partage l in
    merge (triFusion l1) (triFusion l2)

(* D. REPRESENTATION DE FONCTIONS *)
let fst (a,_) = a
let snd (_,b) = b

let estFonction f =
  let rec aux vus f =
    match f with
    | [] -> true
    | (x,_)::xs -> not (List.mem x vus) && aux (x::vus) xs
  in aux [] f

let rec image x f =
  match f with
  | [] -> failwith "pas d'image"
  | (a,b)::xs -> if a = x then b else image x xs

let rec imageEns l f =
  match l with
  | [] -> []
  | x::xs -> image x f :: imageEns xs f

let estInjective f =
  let rec aux vus f =
    match f with
    | [] -> true
    | (_,y)::xs -> not (List.mem y vus) && aux (y::vus) xs
  in aux [] f

let surcharge f1 f2 =
  let rec aux f2 =
    match f2 with
    | [] -> f1
    | (x,y)::xs ->
      let f1' = List.filter (fun (a,_) -> a <> x) f1 in
      (x,y) :: aux xs
  in aux f2

let composition f1 f2 =
  let rec aux f2 =
    match f2 with
    | [] -> []
    | (x,y)::xs ->
      if List.exists (fun (a,_) -> a = y) f1
      then (x, image y f1) :: aux xs
      else aux xs
  in aux f2

let produit f1 f2 =
  let rec img1 x f =
    match f with
    | [] -> failwith "pas d'image"
    | (a,b)::xs -> if x = a then b else img1 x xs
  in
  let rec img2 y f =
    match f with
    | [] -> failwith "pas d'image"
    | (a,b)::xs -> if y = a then b else img2 y xs
  in
  fun (x,y) -> (img1 x f1, img2 y f2)


errores:
ptWrong value [(0, 9); (0, 0); (1, 1)]

Found surcharge with compatible type.

Computing surcharge [('a', true); ('b', false)] [('b', true)]

0 ptWrong value [('b', true); ('a', true); ('b', false)]


let surcharge f1 f2 =
  let rec memfst x l =
    match l with
    | [] -> false
    | (a,_)::xs -> a = x || memfst x xs
  in
  let rec ajout_f2 l =
    match l with
    | [] -> []
    | (x,y)::xs -> (x,y) :: ajout_f2 xs
  in
  let rec ajout_f1 l acc =
    match l with
    | [] -> acc
    | (x,y)::xs ->
        if memfst x f2 then ajout_f1 xs acc
        else ajout_f1 xs ((x,y)::acc)
  in
  let base = ajout_f2 f2 in
  let rec rev l acc =
    match l with
    | [] -> acc
    | x::xs -> rev xs (x::acc)
  in
  rev (ajout_f1 f1 base) []
;;